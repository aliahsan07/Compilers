# Session 3

Created: Feb 5, 2021 10:05 AM
Reviewed: No

### Date: 5 Feb 2021

### Recall

**KEYWORD**

- Context-Free Grammars
- Recursive Descent Parsers

**RELEVANT QUESTION**

What makes a grammar "context free"?

### Notes

### **NFA to DFA in Practice**

NFA to DFA conversion is at the heart of tools such as JFlex.

But DFAs can be huge. Flex-like tools trade off speed for space in the choice of NFA and DFA representations.

---

The functionality of the parser:

- generates parse tree from the lexers

The role of the parser:

- Must distinguish between valid and invalid tokens
- We need a language for describing valid strings of tokens
- A method for distinguishing valid from invalid strings of tokens

RE denote regular language

- We can draw DFA for strings of tokens such as "()", "(())" and "((()))"
- But what about unlimited matching para i.e "(((....)))"? **NO! Because this needs infinite number of states (of '(' and ')' )**

This motivates the use of CFG.

**Context-Free Grammars**

Finite automata can't be constructed for unlimited parenthesis problem, programming language constructs have recursive structure. So Context-Free Grammars are a natural notation for this recursive nature.

CFG consists of

- a set of terminal symbols (terminals are tokens from lexer)
- a set of nonterminals (can be further broken down into symbols)
- a set of productions (substitution rules)
- Start symbol

What makes a grammar "context free"?

- Each production has a single nonterminal symbol on its left side, which makes its production rules be applied without context.

**Why do we bother with going with regular language instead of context free grammar? (Regular Language is a subset of CFG)**

- REs are used to classify identifiers, numbers and keywords
- REs are more concise and simpler for tokens than a grammar
- More efficient lexers can be built from REs than grammars

Context-free grammars are used to count

- brackets: (), if..then..else
- expressions

**Derivation**

The goal is to start from one non terminal and end up with all terminals. 

This ensues that 

- for a nonterminal A in the middle of the sequence of grammar symbols, as in **aAb**, Suppose **A → y,** then we write **aAb ⇒ ayb** (**⇒** means derives in one step)
- **a ⇒* b** means a can be derived to b in zero or more steps.
- If S ⇒* a (S is start symbol), we say that a is sentential form of G.
    - A sentence of G is a sentential form with no terminal

The language generated by a grammar is its set of sentences

- A set of terminals w is in L(G) iff w is a sentence of G i.e ( S ⇒* w)

The language defined by the cfg is a set of strings that can be derived from the start symbol of grammar

- A derivation is a sequence of productions
- Can be drawn as a tree
    - Start symbol is root
    - for a production add children to curr node

Example (String: **id * id + id**)

![lecture03/Untitled.png](lecture03/Untitled.png)

An inorder traversal of the tree is original input.

The parse tree shows the association of operations, the input string does not. 

We're interested in two systemic derivations

- **leftmost derivation:** replace at each step, the leftmost nonterminals (like in the example above)
- **rightmost derivation**: replace at each step, the rightmost nonterminals (

The parse tree generated by both derivations is the same. The way they branch is different.

A grammar is **ambiguous** if it has more than one parse tree for some string (eq there is more than one parse tree for leftmost or rightmost derivation of string)

![lecture03/Untitled%201.png](lecture03/Untitled%201.png)

Why is it important?

The point of the course is to translate source program to target program. (Ambiguity isn't well defined)

A program with different meanings isn't desirable. We need to be aware of ambiguity. 

How to resolve ambiguity?

Cause of ambiguity is precedence of orders not enforced.

**Rewrite the grammar and enforce operator precedence with grammar.** Add extra non-terminals and productions. No way to do multiplication in derivation.

![lecture03/Untitled%202.png](lecture03/Untitled%202.png)

**Instead of rewriting the grammar**

- use the more natural (ambiguous) grammar along with disambiguating declarations
- most tools allow precedence and associativity declarations to disambiguate grammars

---

## Parsing techniques

- **Top-down parsers**
    - start at the root of the parse tree and grow towards leaves
    - pick a production and try to match the input
    - Bad "pick" may need to backtrack
    - Large class of grammars are backtrack free
- **Bottom-up parsers**
    - start at the leaves and grow toward root
    - An input is consumed, encode possibilities in an internal state.
    - Start in a state valid for legal first tokens
    - We can make the process deterministic.

    Bottom-up can support larger set of grammars then top-down.

    **Top-down parsing**

    - **Recursive Descent Parser**
        - highly efficient and flexible
        - typically implemented as hand-coded parser
            - Set of mutually recursive routines
            - works well for any "backtrack free" grammar

            ![lecture03/Untitled%203.png](lecture03/Untitled%203.png)

    - **Table-Driven LL(1) Parser**
        - Takes as input a CFG that is backtrack free
        - Skeleton Parser interprets the table produced by the generator

        ![lecture03/Untitled%204.png](lecture03/Untitled%204.png)

(visualization similar to lexical analysis we saw earlier - parser uses skeleton algo and tab)

Top down parsing isn't deterministic. We might need to backtrack. 

**Example of recursive descent parsing on input string**

![lecture03/Untitled%205.png](lecture03/Untitled%205.png)

### Implementing recursive descent parser

![lecture03/Untitled%206.png](lecture03/Untitled%206.png)

→ To start the parser: initialize *next* pointer to the first token.(E here in the picture). Invoke E()

→ This is easy to implement by hand. But not general and doesn't always work.

**When recursive descent does not work?**

![lecture03/Untitled%207.png](lecture03/Untitled%207.png)

![lecture03/Untitled%208.png](lecture03/Untitled%208.png)

Infinite recursion (unable to converge)

Top-down parsers cannot handle **left-recursive grammars**. Leads to a non-termination in a top-down parser. (Non termination is a bad property)

![lecture03/Untitled%209.png](lecture03/Untitled%209.png)

## Summary:

We are not just interested in whether a string s is part of the language. We also need a parse tree of string s.

A derivation defines a parse tree. But one parse tree may have many derivations.

Ambiguity from grammar can be removed by rewriting productions and adding more non terminals in such a way as to enforce precedence of orders.

Instead of rewriting grammars we can write natural and disambiguating declarations.

Multiple techniques of parsing grammar. Top down v Bottom up.

Looked at top down in this lecture particularly recursive descent.(Table driven LL(1) is the other candidate)

Recursive descent is easy to implement, follows  straightforward rules (which is apply rules in order and backtrack when tokens not match)

But they might result in non termination. Top-down parsers cannot handle left recursive grammars.